---
title: "Computing latencies for each radii/starting position condition"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load packages

```{r}
if(!require(here)) install.packages("here")
library(here)

if(!require(tidyr)) install.packages("tidyr")
library(tidyr)

if(!require(dplyr)) install.packages("dplyr")
library(dplyr)

if(!require(plyr)) install.packages("plyr")
library(plyr)

if(!require(ggplot2)) install.packages("ggplot2")
library(ggplot2)

if(!require(signal)) install.packages("signal")
library(signal)

if(!require(Rmisc)) install.packages("Rmisc")
library(Rmisc)

if(!require(purrr)) install.packages("purrr")
library(purrr)

if(!require(stringr)) install.packages("stringr")
library(stringr)

if(!require(lme4)) install.packages("lme4")
library(lme4)

if(!require(lmerTest)) install.packages("lmerTest")
library(lmerTest)

if(!require(data.table)) install.packages("data.table")
library(data.table)

if(!require(readr)) install.packages("readr")
library(readr)

if(!require(rmarkdown)) install.packages("rmarkdown")
library(rmarkdown)

if(!require(simr)) install.packages("simr")
library(simr)
```

## Theme plot

```{r}
my_cols <- c("#440154FF", "#238A8DFF", "#73D055FF")

theme_plot <- theme(axis.title.x = element_text(size = 15), axis.text.x = element_text(size = 15), axis.title.y = element_text(size = 15), axis.text.y = element_text(size = 15), title = element_text(size = 18), legend.title = element_text(size = 15), legend.text = element_text(size = 15), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))
```

## Load data

Simulation of driver travelling across the z axis (straight ahead) for 0, 4 and 8 m starting position. 

```{r}
"load coordinates"
latency.1000 <- read.csv(here::here("TvA_curves_analysis_data/Midline_Data/Curves.Startingpos_Radius_Straight_Line_Sim.csv")) %>%
  dplyr::mutate(trialid = paste(ppid, trialn, sep = "_")) %>%
  dplyr::mutate(LineVis = case_when(BendVisible == "True" ~ TRUE,
                                    BendVisible == "False" ~ FALSE)) %>%
  dplyr::filter(LineVis == TRUE) %>%
  dplyr::filter(trialn != -1) %>%
  dplyr::group_by(trialid) %>%
  dplyr::mutate(frame = row_number()) %>%
  dplyr::ungroup()

"transforming coordinates from global to local"
latency.1000.0 <- latency.1000 %>%
  dplyr::group_by(trialid) %>%
  dplyr::mutate(World_x_new = World_x - World_x[1]) %>%
  dplyr::mutate(World_z_new = World_z - World_z[1]) %>%
  dplyr::mutate(WorldYaw_rads = WorldYaw / 180 * pi) %>%
  dplyr::mutate(rotatedX = World_x_new * cos(WorldYaw_rads[1]) - World_z_new * sin(WorldYaw_rads[1])) %>%
  dplyr::mutate(rotatedZ = World_x_new * sin(WorldYaw_rads[1]) +  World_z_new * cos(WorldYaw_rads[1])) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(frame) %>%
  dplyr::summarise(x = mean(rotatedX), z = mean(rotatedZ)) %>%
  dplyr::mutate(timestamp = frame / 60) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(radius = 1000, startingpos = 0)

"adding 4 or 8 m onto the z coordinate for starting position manipulation"
latency.1000.4 <- latency.1000.0 %>%
  dplyr::mutate(z = z + 4, startingpos = 4)

latency.1000.8 <- latency.1000.0 %>%
  dplyr::mutate(z = z + 8, startingpos = 8)

latency.1000 <- dplyr::bind_rows(latency.1000.0, latency.1000.4, latency.1000.8)
```

## creating coordinates for each curve radius

```{r}
"1000"
latency.1000.0 <- latency.1000.0 %>%
  dplyr::mutate(X = row_number())

latency.1000.4 <- latency.1000.4 %>%
  dplyr::mutate(X = row_number())

latency.1000.8 <- latency.1000.8 %>%
  dplyr::mutate(X = row_number())

"1500"
latency.1500.0 <- latency.1000.0 %>%
  dplyr::mutate(radius = 1500) %>%
  dplyr::mutate(X = row_number())

latency.1500.4 <- latency.1000.4 %>%
  dplyr::mutate(radius = 1500) %>%
  dplyr::mutate(X = row_number())

latency.1500.8 <- latency.1000.8 %>%
  dplyr::mutate(radius = 1500) %>%
  dplyr::mutate(X = row_number())
  
"2000"
latency.2000.0 <- latency.1000.0 %>%
  dplyr::mutate(radius = 2000) %>%
  dplyr::mutate(X = row_number())

latency.2000.4 <- latency.1000.4 %>%
  dplyr::mutate(radius = 2000) %>%
  dplyr::mutate(X = row_number())

latency.2000.8 <- latency.1000.8 %>%
  dplyr::mutate(radius = 2000) %>%
  dplyr::mutate(X = row_number())

"putting coordinate information in a list"
latencies <- list(latency.1000.0, latency.1000.4, latency.1000.8, latency.1500.0, latency.1500.4, latency.1500.8, latency.2000.0, latency.2000.4, latency.2000.8)
```

## Function for calculating visual angle to a point on the curved road-line

```{r}
"calculation of visual angle looking through curve"
calc_visangle <- function(df, midline, ind){
  # selects the point in the midline closest to the current position in the world 
  
  midlinedist = sqrt(
    ((df$x[ind] - midline[,2])**2)
    +((df$z[ind] - midline[,3] + 10)**2)
  ) 
mid = as.numeric(unlist(midlinedist))

idx = which.min((abs(mid))) # find smallest difference, closest index on the midline

closestpt = midline[idx, 2:3] # closest point b

x_dist = abs(df$x[ind] - closestpt[1])
z_dist = abs(df$z[ind] - closestpt[2])
vis_angle_corrected = tan(x_dist / z_dist) #distance from closest point
  
  return(vis_angle_corrected)
}
```

## generating midline for manuscript figures

```{r}
"dataframe for all 3 midlines"
rmarkdown::render(here::here("TvA_curves_analysis_data/Midline_Data/radii_midline.Rmd"))
midline <- dplyr::bind_rows(midline_1000, midline_1500, midline_2000) %>%
  dplyr::rename(radius = radii)
```

## Iterate the visual angle calculation function

```{r}
"iteration of visual angle function"
iterate <- function(df = steerdata){
  "select the appropriate midline, calculate steering bias per row"
  vis_angle_corrected <- vector(mode = "numeric", length = length(df$X))
  for(i in 1:length(df$X)){
    
    # select midline array
    if(df$radius[i] == 1000){
      midline = midline_1000
      }
    else if(df$radius[i] == 1500){
      midline = midline_1500
    }
    else{
      midline = midline_2000
    }
    
    vis_angle_corrected[[i]] <- calc_visangle(df, midline, ind = i)
    }
  return(vis_angle_corrected)
}
```

## Calculate lateral position error for each condition

```{r}
mid.list <- list(midline_1000, midline_1500, midline_2000)
mid.list.new <- vector(mode = "list", length = 9)

# loop for code below that currently does not work. 

"for (i in c(1:3)){
  mid.tmp <- as.data.frame(mid.list[i]) %>%
    dplyr::mutate(latpos = abs(x))
  
  for (p in c(0, 4, 8)){
    
    mid.tmp <- mid.tmp %>%
      dplyr::mutate(startingpos = p)
  }
    
    if(mid.tmp$startingpos[1] == 0){
      
      mid.tmp <- mid.tmp %>%
        dplyr::select(frame, latpos, startingpos) %>%
        dplyr::mutate(frame = row_number())
    }
  
    if(mid.tmp$startingpos[1] == 4){
      mid.tmp <- mid.tmp %>%
        dplyr::mutate(frame > 29) %>%
        dplyr::select(frame, latpos, startingpos) %>%
        dplyr::mutate(frame = row_number())
    }
    if(mid.tmp$startingpos[1] == 8){
      
      mid.8 <- mid.tmp %>%
        dplyr::mutate(frame > 59) %>%
        dplyr::select(frame, latpos, startingpos) %>%
        dplyr::mutate(frame = row_number())
    }
    
  }
  
  mid.list.new[[i]] <- mid.tmp"


"1000"
midline_1000.0 <- midline_1000 %>%
  dplyr::mutate(steeringbias = abs(x), startingpos = 0) %>%
  dplyr::select(frame, steeringbias, startingpos) %>%
  dplyr::mutate(frame = row_number(), radius = 1000)


midline_1000.4 <- midline_1000 %>%
  dplyr::filter(frame > 29) %>%
  dplyr::mutate(startingpos = 4, steeringbias = abs(x)) %>%
  dplyr::select(frame, steeringbias, startingpos) %>%
  dplyr::mutate(frame = row_number(), radius = 1000)

midline_1000.8 <- midline_1000 %>%
  dplyr::filter(frame > 59) %>%
  dplyr::mutate(startingpos = 8, steeringbias = abs(x)) %>%
  dplyr::select(frame, steeringbias, startingpos) %>%
  dplyr::mutate(frame = row_number(), radius = 1000)

"1500"
midline_1500.0 <- midline_1500 %>%
  dplyr::mutate(steeringbias = abs(x), startingpos = 0) %>%
  dplyr::select(frame, steeringbias, startingpos) %>%
  dplyr::mutate(frame = row_number(), radius = 1500)


midline_1500.4 <- midline_1500 %>%
  dplyr::filter(frame > 29) %>%
  dplyr::mutate(startingpos = 4, steeringbias = abs(x)) %>%
  dplyr::select(frame, steeringbias, startingpos) %>%
  dplyr::mutate(frame = row_number(), radius = 1500)

midline_1500.8 <- midline_1500 %>%
  dplyr::filter(frame > 59) %>%
  dplyr::mutate(startingpos = 8, steeringbias = abs(x)) %>%
  dplyr::select(frame, steeringbias, startingpos) %>%
  dplyr::mutate(frame = row_number(), radius = 1500)

"2000"
midline_2000.0 <- midline_2000 %>%
  dplyr::mutate(steeringbias = abs(x), startingpos = 0) %>%
  dplyr::select(frame, steeringbias, startingpos) %>%
  dplyr::mutate(frame = row_number(), radius = 2000)


midline_2000.4 <- midline_2000 %>%
  dplyr::filter(frame > 29) %>%
  dplyr::mutate(startingpos = 4, steeringbias = abs(x)) %>%
  dplyr::select(frame, steeringbias, startingpos) %>%
  dplyr::mutate(frame = row_number(), radius = 2000)

midline_2000.8 <- midline_2000 %>%
  dplyr::filter(frame > 59) %>%
  dplyr::mutate(startingpos = 8, steeringbias = abs(x)) %>%
  dplyr::select(frame, steeringbias, startingpos) %>%
  dplyr::mutate(frame = row_number(), radius = 2000)

"putting coordinate information in a list"
steering <- list(midline_1000.0, midline_1000.4, midline_1000.8, midline_1500.0, midline_1500.4, midline_1500.8, midline_2000.0, midline_2000.4, midline_2000.8)
```

## Caclualate lateral position and visual angle for straight line sim relative to various radii curves

Visual angle and lateral position error are equivlent, however steering bias does increase at a faster rate than visual angle initially, and this is exacerbated for larger radii curves. Hence when using visual angle as perceptual input for the Threshold framework, we might expect slightly larger lateral position errors. 
.
```{r}
"create empty list for dataframes"
latency.df <- data.frame()
latency.list <- vector(mode = "list", length = 9)

"for each data frame in the list, compute the steering bias and visual angle"
for (i in 1:9){
  latencies_tmp <- as.data.frame(latencies[i])
  
  mid_tmp <- as.data.frame(steering[i])
  
  latencies_tmp$vis_angle_corrected <- matrix(unlist(iterate(df = latencies_tmp)), nrow = 301, byrow = TRUE)
  
  latencies_tmp <- latencies_tmp %>%
    dplyr::mutate(visangle_rads = abs(vis_angle_corrected)) %>%
    dplyr::mutate(visangle = visangle_rads * 180/pi) %>%
    dplyr::mutate(visangle.diff = c(0, diff(visangle))) %>%
    dplyr::select(-startingpos)
  
  latencies_tmp <- merge(latencies_tmp, mid_tmp, by = "frame")
  
  latencies_tmp <- latencies_tmp %>%
    dplyr::mutate(sb.diff = c(0, diff(steeringbias)))
  
  latency.df <- rbind(latency.df, latencies_tmp)
  
  latency.list[[i]] <- latencies_tmp
}


"0 m starting position condition for each radius - lateral position error and visual angle"
ggplot(latency.df %>%
         dplyr::filter(timestamp < 3.5), mapping = aes(x = timestamp, y = steeringbias, col = as.factor(radius.x))) +
  geom_line() +
  facet_wrap(~ startingpos)

ggplot(latency.df %>%
         dplyr::filter(timestamp < 3.5), mapping = aes(x = timestamp, y = visangle, col = as.factor(radius.x))) +
  geom_line() +
  facet_wrap(~ startingpos)
```

## Reaction time predictions for Accumulator and Threshold frameworks

```{r}
"for each dataframe, select a time and lateral position from the road-line once the accumulated steering bias has surpassed a threshold"

df_accum <- data.frame()

for (i in 1:9){
  latencies_tmp <- as.data.frame(latency.list[i])
  
  for (a in c(3)){
      
    latencies_tmp <- latencies_tmp %>%
      dplyr::filter(timestamp <= 3) %>%
      dplyr::mutate(accum = cumsum(visangle)) %>%
      dplyr::filter(accum > a) %>%
      dplyr::mutate(threshold = a)
      
    
    latencies.coords.tmp <- latencies_tmp[10,]
    
    df_accum <-  rbind(df_accum, latencies.coords.tmp)
    
  }
}

"for each dataframe, select a time and lateral position from the road-line once the accumulated steering bias has surpassed a threshold"
df_thresh <- data.frame()

for (i in 1:9){
  latencies_tmp <- as.data.frame(latency.list[i])
  
  for (a in c(.9)){
      
    latencies_tmp <- latencies_tmp %>%
      dplyr::filter(timestamp <= 3.5) %>%
      dplyr::filter(visangle > a) %>%
      dplyr::mutate(threshold = a)
    
    latencies.coords.tmp <- latencies_tmp[10,]
    
    df_thresh <-  rbind(df_thresh, latencies.coords.tmp)
    
  }
}

write.csv(df_accum, file = here::here("TvA_curves_analysis_data/Prediction_Data/df_accum.csv"))

write.csv(df_thresh, file = here::here("TvA_curves_analysis_data/Prediction_Data/df_thresh.csv"))
```

## Figure 13: Threshold predictions across differing motor latencies

Below we calculate the lateral position error for a range of motor latencies to see if a Threshold could produce Accumulator effects with a big enough motor delay. 

```{r}
"for each dataframe, select a time and lateral position from the road-line once visual angle has surpassed a fixed threshold"

df_thresh <- data.frame()

for (i in 1:9){
  latencies_tmp <- as.data.frame(latency.list[i])
  
  for (a in c(seq(10, 40, by = 10))){
      
    latencies_tmp <- latencies_tmp %>%
      dplyr::filter(visangle > .9)
      
    
    latencies.coords.tmp <- latencies_tmp[a,]
    
    latencies.coords.tmp <- latencies.coords.tmp %>%
      dplyr::mutate(latency = a)
    
    df_thresh <-  rbind(df_thresh, latencies.coords.tmp)
    
  }
  
  
}

latency.labs <- c("10" = "Latency = 150 ms", "20" = "Latency = 300 ms", "30" = "Latency = 450 ms", "40" = "Latency = 600 ms")

ggplot(df_thresh, mapping = aes(x = radius.x, y = steeringbias, linetype = as.factor(startingpos))) +
  geom_line() +
  facet_wrap(~ latency, labeller = labeller(latency = latency.labs)) +
  #scale_y_continuous(breaks = c(0.015, 0.02, 0.025), limits = c(0.01, 0.03)) +
  scale_x_continuous(breaks = c(1000, 1500, 2000), limits = c(900, 2100)) +
  scale_linetype_manual(name = "Starting position (m)", values = c("dotted", "dashed", "solid"), guide = guide_legend(reverse = TRUE)) +
  xlab("Radius (m)") +
  ylab("Lateral position error (m)") +
  theme_plot +
  theme(legend.position = c(.51, .60), legend.key.height = unit(0, 'cm'), legend.key.width = unit(0.5, 'cm'), strip.text = element_text(size = 12, face = "bold"), legend.key = element_blank(), panel.spacing = unit(2, "lines"), legend.spacing.y = unit(0.1, "cm"), legend.margin = margin(0.05,0.05,0,0, unit = "cm"), legend.key.size = unit(0, 'cm'), plot.title = element_text(size = 12, face = "bold"), axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 11), title = element_text(size = 7), legend.title = element_text(size = 10), legend.text = element_text(size = 10))

  ggsave(here::here("TvA_curves_analysis_data/Plots/Fig13.tiff"), plot = last_plot(), width = 10, height = 10, units = 'cm', dpi = 600, type = 'cairo')
```


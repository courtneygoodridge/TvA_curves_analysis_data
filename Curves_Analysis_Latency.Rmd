---
title: "Computing latencies for each radii/starting position condition"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load packages

```{r}
if(!require(here)) install.packages("here")
library(here)

if(!require(tidyr)) install.packages("tidyr")
library(tidyr)

if(!require(dplyr)) install.packages("dplyr")
library(dplyr)

if(!require(plyr)) install.packages("plyr")
library(plyr)

if(!require(ggplot2)) install.packages("ggplot2")
library(ggplot2)

if(!require(signal)) install.packages("signal")
library(signal)

if(!require(Rmisc)) install.packages("Rmisc")
library(Rmisc)

if(!require(purrr)) install.packages("purrr")
library(purrr)

if(!require(stringr)) install.packages("stringr")
library(stringr)

if(!require(lme4)) install.packages("lme4")
library(lme4)

if(!require(lmerTest)) install.packages("lmerTest")
library(lmerTest)

if(!require(data.table)) install.packages("data.table")
library(data.table)

if(!require(readr)) install.packages("readr")
library(readr)

if(!require(rmarkdown)) install.packages("rmarkdown")
library(rmarkdown)
```

## Load data

Simulation of driver travelling across the z axis (straight ahead) for 0, 4 and 8 m starting position. 

```{r}
"load coordinates"
latency.1000 <- read.csv(here::here("TvA_curves_analysis_data/Midline_Data/Curves.Startingpos_radius_2000_latency.csv")) %>%
  dplyr::mutate(trialid = paste(ppid, trialn, sep = "_")) %>%
  dplyr::mutate(LineVis = case_when(BendVisible == "True" ~ TRUE,
                                    BendVisible == "False" ~ FALSE)) %>%
  dplyr::filter(LineVis == TRUE) %>%
  dplyr::filter(trialn != -1) %>%
  dplyr::group_by(trialid) %>%
  dplyr::mutate(frame = row_number()) %>%
  dplyr::ungroup()

"transforming coordinates from global to local"
latency.1000.0 <- latency.1000 %>%
  dplyr::group_by(trialid) %>%
  dplyr::mutate(World_x_new = World_x - World_x[1]) %>%
  dplyr::mutate(World_z_new = World_z - World_z[1]) %>%
  dplyr::mutate(WorldYaw_rads = WorldYaw / 180 * pi) %>%
  dplyr::mutate(rotatedX = World_x_new * cos(WorldYaw_rads[1]) - World_z_new * sin(WorldYaw_rads[1])) %>%
  dplyr::mutate(rotatedZ = World_x_new * sin(WorldYaw_rads[1]) +  World_z_new * cos(WorldYaw_rads[1])) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(frame) %>%
  dplyr::summarise(x = mean(rotatedX), z = mean(rotatedZ)) %>%
  dplyr::mutate(timestamp = frame / 60) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(radius = 1000, startingpos = 0)


latency.1000.4 <- latency.1000.0 %>%
  dplyr::mutate(z = z + 4, startingpos = 4)

latency.1000.8 <- latency.1000.0 %>%
  dplyr::mutate(z = z + 8, startingpos = 8)

latency.1000 <- dplyr::bind_rows(latency.1000.0, latency.1000.4, latency.1000.8)
```

## creating coordinates for each curve radius

```{r}
"1000"
latency.1000.0 <- latency.1000.0 %>%
  dplyr::mutate(X = row_number())

latency.1000.4 <- latency.1000.4 %>%
  dplyr::mutate(X = row_number())

latency.1000.8 <- latency.1000.8 %>%
  dplyr::mutate(X = row_number())

"1500"
latency.1500.0 <- latency.1000.0 %>%
  dplyr::mutate(radius = 1500) %>%
  dplyr::mutate(X = row_number())

latency.1500.4 <- latency.1000.4 %>%
  dplyr::mutate(radius = 1500) %>%
  dplyr::mutate(X = row_number())

latency.1500.8 <- latency.1000.8 %>%
  dplyr::mutate(radius = 1500) %>%
  dplyr::mutate(X = row_number())
  
"2000"
latency.2000.0 <- latency.1000.0 %>%
  dplyr::mutate(radius = 2000) %>%
  dplyr::mutate(X = row_number())

latency.2000.4 <- latency.1000.4 %>%
  dplyr::mutate(radius = 2000) %>%
  dplyr::mutate(X = row_number())

latency.2000.8 <- latency.1000.8 %>%
  dplyr::mutate(radius = 2000) %>%
  dplyr::mutate(X = row_number())

"putting coordinate information in a list"
latencies <- list(latency.1000.0, latency.1000.4, latency.1000.8, latency.1500.0, latency.1500.4, latency.1500.8, latency.2000.0, latency.2000.4, latency.2000.8)
```

## Computing latency for each radius/starting position condition

Here I compute steering bias at the position a driver would be relative to the road-line after 150 ms from when the line was shown.  

1) calculate steering bias for entire linear trajectory across each starting position. 

2) for a given "fixed threshold" calculate a further 150 ms ahead and calculate extra steering bias 

3) the resulting lateral position error would be the result if drivers responded at a fixed lateral position error and under a 150 ms 

**TO DO**

WORK OUT HOW TO FILTER FOR TIMESTAMP OF 0.15 s WITHIN EACH DATAFRAME WITHIN EACH LIST.

How the motor latency will be at the point they respond, not initially, and rate of change in lateral position error increase will change as they move across the z axis.

So I need to pick an artificial fixed threshold (say 0.02 m) and then calculate 150 ms beyond this point, plot the lateral position errors within each radii/starting position condition, and then see 1) if the pattern/magnitude of results is similar to Accumulator.

```{r}
"calculation of steering bias function"
calc <- function(df, midline, ind){
  # selects the point in the midline closest to the current position in the world 
  
  midlinedist = sqrt(
    ((df$x[ind] - midline[,2])**2)
    +((df$z[ind] - midline[,3])**2)
  ) 
  mid = as.numeric(unlist(midlinedist))
  
  idx = which.min((abs(mid))) #find smallest difference. This is the closest index on the midline.
  
  closestpt = midline[idx, 2:3] #xy of closest point
  dist = midlinedist[idx, ] #distance from closest point				
  origin = midline[1, 2:3]
  
  #Sign bias from assessing if the closest point on midline is closer to the track origin than the driver position. 
  #Since the track is an oval, closer = understeering, farther = oversteering.
  
  middist_from_origin = sqrt(
    ((closestpt[1] - origin[1])**2)
    +((closestpt[2]-origin[2])**2)
  )  #distance of midline to origin
  
  pos_from_trackorigin = sqrt(
    ((df$z[ind] - origin[1])**2)
    +((df$z[ind] - origin[2])**2)
  ) #distance of driver position to origin
  
  #if driver distance is greater than closest point distance, steering position should be understeering
  distdiff = middist_from_origin - pos_from_trackorigin 
  steeringbias = dist * sign(distdiff)
  steeringbias = as.numeric(as.character(unlist(steeringbias)))
  
  return(steeringbias)
}

"iteration of steering bias function"
iterate_bias <- function(df = steerdata){
  "select the appropriate midline, calculate steering bias per row"
  steeringbias <- vector(mode = "numeric", length = length(df$X))
  for(i in 1:length(df$X)){
    
    # select midline array
    if(df$radius[i] == 1000){
      midline = midline_1000
      }
    else if(df$radius[i] == 1500){
      midline = midline_1500
    }
    else{
      midline = midline_2000
    }
      
    steeringbias[[i]] <- calc(df, midline, ind = i)
    }
  return(steeringbias)
}

"create empty list for dataframes"
latency.list <- vector(mode = "list", length = 9)

"for each data frame in the list, coompute the steering bias"
for (i in 1:9){
  latencies_tmp <- as.data.frame(latencies[i])
  
  latencies_tmp$steeringbias <- iterate_bias(df = latencies_tmp)
  
  latencies_tmp <- latencies_tmp %>%
    dplyr::mutate(steeringbias = abs(steeringbias))
  
  latency.list[[i]] <- latencies_tmp
}

"create empty dataframe"
latency.coords.2 <- setNames(data.frame(matrix(ncol = 8, nrow = 0)), c("frame", "x", "z", "timestamp", "radius", "startingpos", "X", "steeringbias"))


"NOTE: THIS FOR LOOP DOESN'T WORK (YET) for each dataframe in the list, filter the observation at 0.15 s"
for (i in 1:9){
  latencies_tmp <- as.data.frame(latency.list[i])
  
  coord_tmp <- latencies_tmp %>%
    dplyr::filter(timestamp == 0.15)
  
  latency.coords.2 <- latency.coords.2 %>%
    dplyr::bind_rows(coord_tmp[i])
}
```

## plotting trajectory and lateral position after 150 ms

```{r}
ggplot() +
  geom_path(midline, mapping = aes(x = x, y = z)) +
  geom_point(latency.coords, mapping = aes(x = x, y = z, col = as.factor(startingpos))) +
  facet_wrap(~ radius) +
  xlim(0, -.2) +
  ylim(0,20)


ggplot() +
  geom_point(latency.coords, mapping = aes(radius, y = steeringbias, col = as.factor(startingpos)), alpha = 0.5) +
   scale_x_continuous(breaks = c(1000, 1500, 2000), limits = c(900, 2100)) +
  ylim(0, 0.08)


ggplot() +
  geom_point(latency.coords, mapping = aes(radius, y = steeringbias + 0.03, col = as.factor(startingpos)), alpha = 0.5) +
  geom_hline(aes(yintercept = 0.03)) +
  scale_x_continuous(breaks = c(1000, 1500, 2000), limits = c(900, 2100)) +
  ylim(0, 0.08)





```

## Data saving

```{r}
write.csv(latency.coords, file = here::here("TvA_curves_analysis_data/Participant_Data/latency_coords.csv"))
```

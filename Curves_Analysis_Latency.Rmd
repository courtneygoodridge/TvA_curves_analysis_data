---
title: "Computing latencies for each radii/starting position condition"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load packages

```{r}
if(!require(here)) install.packages("here")
library(here)

if(!require(tidyr)) install.packages("tidyr")
library(tidyr)

if(!require(dplyr)) install.packages("dplyr")
library(dplyr)

if(!require(plyr)) install.packages("plyr")
library(plyr)

if(!require(ggplot2)) install.packages("ggplot2")
library(ggplot2)

if(!require(signal)) install.packages("signal")
library(signal)

if(!require(Rmisc)) install.packages("Rmisc")
library(Rmisc)

if(!require(purrr)) install.packages("purrr")
library(purrr)

if(!require(stringr)) install.packages("stringr")
library(stringr)

if(!require(lme4)) install.packages("lme4")
library(lme4)

if(!require(lmerTest)) install.packages("lmerTest")
library(lmerTest)

if(!require(data.table)) install.packages("data.table")
library(data.table)

if(!require(readr)) install.packages("readr")
library(readr)

if(!require(rmarkdown)) install.packages("rmarkdown")
library(rmarkdown)
```

## Load data

Simulation of driver travelling across the z axis (straight ahead) for 0, 4 and 8 m starting position. 

```{r}
"1000"
latency.1000 <- read.csv(here::here("TvA_curves_analysis_data/Midline_Data/Curves.Startingpos_radius_1000_latency.csv")) %>%
  dplyr::mutate(trialid = paste(ppid, trialn, sep = "_")) %>%
  dplyr::mutate(LineVis = case_when(BendVisible == "True" ~ TRUE,
                                    BendVisible == "False" ~ FALSE)) %>%
  dplyr::filter(LineVis == TRUE) %>%
  dplyr::filter(trialn != -1) %>%
  dplyr::group_by(trialid) %>%
  dplyr::mutate(frame = row_number()) %>%
  dplyr::ungroup()

"transforming coordinates from global to local"
latency.1000 <- latency.1000 %>%
  dplyr::group_by(trialid) %>%
  dplyr::mutate(World_x_new = World_x - World_x[1]) %>%
  dplyr::mutate(World_z_new = World_z - World_z[1]) %>%
  dplyr::mutate(WorldYaw_rads = WorldYaw / 180 * pi) %>%
  dplyr::mutate(rotatedX = World_x_new * cos(WorldYaw_rads[1]) - World_z_new * sin(WorldYaw_rads[1])) %>%
  dplyr::mutate(rotatedZ = World_x_new * sin(WorldYaw_rads[1]) +  World_z_new * cos(WorldYaw_rads[1])) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(startingpos, frame) %>%
  dplyr::summarise(x = mean(rotatedX), z = mean(rotatedZ)) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(startingpos) %>%
  dplyr::mutate(z = z + startingpos, timestamp = frame / 60) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(radius = 1000)

"1500"
latency.1500 <- read.csv(here::here("TvA_curves_analysis_data/Midline_Data/Curves.Startingpos_radius_1500_latency.csv")) %>%
  dplyr::mutate(trialid = paste(ppid, trialn, sep = "_")) %>%
  dplyr::mutate(LineVis = case_when(BendVisible == "True" ~ TRUE,
                                    BendVisible == "False" ~ FALSE)) %>%
  dplyr::filter(LineVis == TRUE) %>%
  dplyr::filter(trialn != -1) %>%
  dplyr::group_by(trialid) %>%
  dplyr::mutate(frame = row_number()) %>%
  dplyr::ungroup()

"transforming coordinates from global to local"
latency.1500 <- latency.1500 %>%
  dplyr::group_by(trialid) %>%
  dplyr::mutate(World_x_new = World_x - World_x[1]) %>%
  dplyr::mutate(World_z_new = World_z - World_z[1]) %>%
  dplyr::mutate(WorldYaw_rads = WorldYaw / 180 * pi) %>%
  dplyr::mutate(rotatedX = World_x_new * cos(WorldYaw_rads[1]) - World_z_new * sin(WorldYaw_rads[1])) %>%
  dplyr::mutate(rotatedZ = World_x_new * sin(WorldYaw_rads[1]) +  World_z_new * cos(WorldYaw_rads[1])) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(startingpos, frame) %>%
  dplyr::summarise(x = mean(rotatedX), z = mean(rotatedZ)) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(startingpos) %>%
  dplyr::mutate(z = z + startingpos, timestamp = frame / 60) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(radius = 1500)

"2000"
latency.2000 <- read.csv(here::here("TvA_curves_analysis_data/Midline_Data/Curves.Startingpos_radius_2000_latency.csv")) %>%
  dplyr::mutate(trialid = paste(ppid, trialn, sep = "_")) %>%
  dplyr::mutate(LineVis = case_when(BendVisible == "True" ~ TRUE,
                                    BendVisible == "False" ~ FALSE)) %>%
  dplyr::filter(LineVis == TRUE) %>%
  dplyr::filter(trialn != -1) %>%
  dplyr::group_by(trialid) %>%
  dplyr::mutate(frame = row_number()) %>%
  dplyr::ungroup()

"transforming coordinates from global to local"
latency.2000 <- latency.2000 %>%
  dplyr::group_by(trialid) %>%
  dplyr::mutate(World_x_new = World_x - World_x[1]) %>%
  dplyr::mutate(World_z_new = World_z - World_z[1]) %>%
  dplyr::mutate(WorldYaw_rads = WorldYaw / 180 * pi) %>%
  dplyr::mutate(rotatedX = World_x_new * cos(WorldYaw_rads[1]) - World_z_new * sin(WorldYaw_rads[1])) %>%
  dplyr::mutate(rotatedZ = World_x_new * sin(WorldYaw_rads[1]) +  World_z_new * cos(WorldYaw_rads[1])) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(startingpos, frame) %>%
  dplyr::summarise(x = mean(rotatedX), z = mean(rotatedZ)) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(startingpos) %>%
  dplyr::mutate(z = z + startingpos, timestamp = frame / 60) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(radius = 2000)
```

## Filtering observations at 0.15 s (150 ms)

```{r}
latency.coords.1000 <- latency.1000 %>%
  dplyr::group_by(startingpos) %>%
  dplyr::filter(timestamp == 0.15)

latency.coords.1500 <- latency.1500 %>%
  dplyr::group_by(startingpos) %>%
  dplyr::filter(timestamp == 0.15) %>%
  dplyr::ungroup()

latency.coords.2000 <- latency.2000 %>%
  dplyr::group_by(startingpos) %>%
  dplyr::filter(timestamp == 0.15) %>%
  dplyr::ungroup()

latency.coords <- dplyr::bind_rows(latency.coords.1000, latency.coords.1500, latency.coords.2000) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(X = row_number())
```

## Computing latency for each radius/starting position condition

Here I compute steering bias at the position a driver would be relative to the road-line after 150 ms from when the line was shown.  

```{r}
"calculation of steering bias function"
calc <- function(df, midline, ind){
  # selects the point in the midline closest to the current position in the world 
  
  midlinedist = sqrt(
    ((df$x[ind] - midline[,2])**2)
    +((df$z[ind] - midline[,3])**2)
  ) 
  mid = as.numeric(unlist(midlinedist))
  
  idx = which.min((abs(mid))) #find smallest difference. This is the closest index on the midline.
  
  closestpt = midline[idx, 2:3] #xy of closest point
  dist = midlinedist[idx, ] #distance from closest point				
  origin = midline[1, 2:3]
  
  #Sign bias from assessing if the closest point on midline is closer to the track origin than the driver position. 
  #Since the track is an oval, closer = understeering, farther = oversteering.
  
  middist_from_origin = sqrt(
    ((closestpt[1] - origin[1])**2)
    +((closestpt[2]-origin[2])**2)
  )  #distance of midline to origin
  
  pos_from_trackorigin = sqrt(
    ((df$z[ind] - origin[1])**2)
    +((df$z[ind] - origin[2])**2)
  ) #distance of driver position to origin
  
  #if driver distance is greater than closest point distance, steering position should be understeering
  distdiff = middist_from_origin - pos_from_trackorigin 
  steeringbias = dist * sign(distdiff)
  steeringbias = as.numeric(as.character(unlist(steeringbias)))
  
  return(steeringbias)
}

"iteration of steering bias function"
iterate_bias <- function(df = steerdata){
  "select the appropriate midline, calculate steering bias per row"
  steeringbias <- vector(mode = "numeric", length = length(df$X))
  for(i in 1:length(df$X)){
    
    # select midline array
    if(df$radius[i] == 1000){
      midline = midline_1000
      }
    else if(df$radius[i] == 1500){
      midline = midline_1500
    }
    else{
      midline = midline_2000
    }
      
    steeringbias[[i]] <- calc(df, midline, ind = i)
    }
  return(steeringbias)
}

latency.coords$steeringbias <- iterate_bias(df = latency.coords)

latency.coords <- latency.coords %>%
  dplyr::mutate(steeringbias = abs(steeringbias))
```

## Data saving

```{r}
write.csv(latency.coords, file = here::here("TvA_curves_analysis_data/Participant_Data/latency_coords.csv"))
```
